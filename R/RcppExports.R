# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Beta function, see Definition 3.3.
#' This is AGammaProcessPrior::beta() in beyondWhittle(a_gamma_process_prior.cpp)
#' @keywords internal
beta_fun_AGamma_process_cube <- function(U_, Sigma_) {
    .Call(`_vnpctest_beta_fun_AGamma_process_cube`, U_, Sigma_)
}

#' Add W * b_{j,k} to the psd f (W being the Gamma process weight and b_{j,k}
#' being the j'the basis polynomial of degree k) See (5.3).
#' This is inside of bernsteinGammaPsd() in beyondWhittle(bernstein_gamma_psd.cpp),
#' in which the function is classified into two versions: one is the local
#' recomputation and one is the full recomputation
#' @keywords internal
get_mix_rcpp <- function(w_, densities) {
    .Call(`_vnpctest_get_mix_rcpp`, w_, densities)
}

#' Get the product of U and r for the construction of the Gamma process. See (5.7)
#' This is inside of bernsteinGammaPsd::get_W() in beyondWhittle(bernstein_gamma_psd.cpp).
#' @keywords internal
cubeTimesVector <- function(U_, r) {
    .Call(`_vnpctest_cubeTimesVector`, U_, r)
}

#' Get the Gamma process weight. See (5.7). This is inside of bernsteinGammaPsd::get_W()
#' in beyondWhittle(bernstein_gamma_psd.cpp).
#' @keywords internal
get_w_rcpp <- function(p_, Z, k) {
    .Call(`_vnpctest_get_w_rcpp`, p_, Z, k)
}

#' Log alpha star density function for the prior of AGamma process. See (3.26) in Meier (2018).
#' This is AGammaProcessPrior::lalpha() in beyondWhittle(a_gamma_process_prior.cpp).
#' @keywords
lalphaStar_AGamma <- function(U_, eta, Sigma_) {
    .Call(`_vnpctest_lalphaStar_AGamma`, U_, eta, Sigma_)
}

#' I/O: Only use *within* Rcpp in beyondWhittle(matrix_cube.cpp)
#'
#' @keywords internal
cx_cube_from_ComplexVector <- function(x) {
    .Call(`_vnpctest_cx_cube_from_ComplexVector`, x)
}

#' I/O: Only use *within* Rcpp
#'
#' @keywords internal in beyondWhittle(matrix_cube.cpp)
cube_from_NumericVector <- function(x) {
    .Call(`_vnpctest_cube_from_NumericVector`, x)
}

#' Get VARMA PSD from transfer polynomials
#' Helping function for \code{psd_varma} in beyondWhittle(varma.cpp)
#' @keywords internal
varma_transfer2psd <- function(transfer_ar_, transfer_ma_, sigma) {
    .Call(`_vnpctest_varma_transfer2psd`, transfer_ar_, transfer_ma_, sigma)
}

#' VARMA transfer polynomials in beyondWhittle(varma.cpp)
#'
#' @keywords internal
transfer_polynomial <- function(lambda, coef) {
    .Call(`_vnpctest_transfer_polynomial`, lambda, coef)
}

#' Store imaginary parts above and real parts below the diagonal
#' in beyondWhittle(vnp_help.cpp)
#' @keywords internal
realValuedPsd <- function(f_) {
    .Call(`_vnpctest_realValuedPsd`, f_)
}

#' Epsilon process (residuals) of VAR model in beyondWhittle(varma.cpp)
#' @keywords internal
epsilon_var <- function(zt, ar) {
    .Call(`_vnpctest_epsilon_var`, zt, ar)
}

#' Sum of multivariate normal log densities
#' with mean 0 and covariance Sigma, unnormalized in beyondWhittle(varma.cpp)
#' @keywords internal
sldmvnorm <- function(z_t, Sigma) {
    .Call(`_vnpctest_sldmvnorm`, z_t, Sigma)
}

#' Build an nd times nd Block Toeplitz matrix from the
#' (d times d) autocovariances gamma(0),...,gamma(n-1) in beyondWhittle(misc.cpp)
#' called acvBlockMatrix()
#' @keywords internal
acvToeplitz <- function(acv) {
    .Call(`_vnpctest_acvToeplitz`, acv)
}

#' Build the correction matrix in the frequency domain
#' @keywords internal
get_CFZ <- function(FZ, f_half_inv_, f_param_half_, excludeBoundary) {
    .Call(`_vnpctest_get_CFZ`, FZ, f_half_inv_, f_param_half_, excludeBoundary)
}

#' Build the correction matrix in the frequency domain based on the q-parametrization with the Cholesky decomposition
#' @keywords internal
get_CFZ_q <- function(FZ, q_, f_param_half_, excludeBoundary) {
    .Call(`_vnpctest_get_CFZ_q`, FZ, q_, f_param_half_, excludeBoundary)
}

#' Build the correction matrix in the frequency domain based on the q-parametrization with square root of matrices
#' @keywords internal
get_CFZ_q_sq <- function(FZ, q_, f_param_half_, excludeBoundary) {
    .Call(`_vnpctest_get_CFZ_q_sq`, FZ, q_, f_param_half_, excludeBoundary)
}

#' Cholesky docomposition representation of a matrix array. See Remark 5.2
#' @keywords internal
chol_cube <- function(f_, excludeBoundary) {
    .Call(`_vnpctest_chol_cube`, f_, excludeBoundary)
}

#' Square root of a matrix array. See Remark 5.2
#' @keywords internal
sqrt_cube <- function(f_, excludeBoundary) {
    .Call(`_vnpctest_sqrt_cube`, f_, excludeBoundary)
}

#' Inverse matrices of a matrix array
#' @keywords internal
inv_cube <- function(f_, excludeBoundary) {
    .Call(`_vnpctest_inv_cube`, f_, excludeBoundary)
}

#' Matrix products of a matrix array
#' @keywords internal
mult_cube <- function(a_, b_) {
    .Call(`_vnpctest_mult_cube`, a_, b_)
}

#' Log determinants of a matrix array
#' @keywords internal
logdet_cube <- function(f_, excludeBoundary) {
    .Call(`_vnpctest_logdet_cube`, f_, excludeBoundary)
}

#' Transform all matrices of the array into the same desirable matrix
#' @keywords
const_cube <- function(sigma, N) {
    .Call(`_vnpctest_const_cube`, sigma, N)
}

#' Hermitian conjugate of a matrix array
#' @keywords internal
trans_cube <- function(f_) {
    .Call(`_vnpctest_trans_cube`, f_)
}

#' Recursion of a matrix array?
#' @keywords internal
rev_cube <- function(f_) {
    .Call(`_vnpctest_rev_cube`, f_)
}

#' Combine two matric arrays?
#' @keywords internal
c_cube <- function(f_, g_) {
    .Call(`_vnpctest_c_cube`, f_, g_)
}

#' Generate random variables from the complex Wishart distribution
#' @keywords internal
rcWishart <- function(nu, Sigma_half) {
    .Call(`_vnpctest_rcWishart`, nu, Sigma_half)
}

#' Transpose of the Cholesky docomposition
#' @keywords internal
chol_cpp <- function(A) {
    .Call(`_vnpctest_chol_cpp`, A)
}

#' Does a matrix have an eigenvalue smaller than 0? in beyondWhittle(matrix_cube.cpp)
#' @keywords internal
hasEigenValueSmallerZero <- function(A, TOL = 0.0) {
    .Call(`_vnpctest_hasEigenValueSmallerZero`, A, TOL)
}

#' Trace of matrices
#' @keywords internal
tr <- function(A) {
    .Call(`_vnpctest_tr`, A)
}

#' Inverse condition number
#' @keywords internal
matCond <- function(A) {
    .Call(`_vnpctest_matCond`, A)
}

#' Is the conditional number too large? See Section 5.2.3 in Meier (2008)
#' @keywords internal
numericalUnstable <- function(f_, excludeBoundary, TOL = 1e-12) {
    .Call(`_vnpctest_numericalUnstable`, f_, excludeBoundary, TOL)
}

#' Computing acceptance rate based on trace
#' Note: Only use for traces from continous distributions!
#' This is in beyondWhittle(misc.cpp)
#' @keywords internal
acceptanceRate <- function(trace) {
    .Call(`_vnpctest_acceptanceRate`, trace)
}

#' Get x from phi, see (62) in Mittelbach et al.
#' This is unit_trace_x_from_phi() in beyondWhittle(unit_trace.cpp)
#' @keywords internal
cholesky_xFromPhi <- function(phi) {
    .Call(`_vnpctest_cholesky_xFromPhi`, phi)
}

#' Get L (lower triangular Cholesky) from x
#' Called U^* in Mittelbach et al, see (60) there
#' This is unit_trace_L_from_x() in beyondWhittle(unit_trace.cpp)
#' @keywords internal
cholseky_LFromx <- function(x) {
    .Call(`_vnpctest_cholseky_LFromx`, x)
}

#' log determinant of Jacobian, see (5.12)
#' This is unit_trace_jacobian_log_determinant() in beyondWhittle(unit_trace.cpp)
#' @keywords internal
cholesky_jacobianLogDeterminant <- function(phi) {
    .Call(`_vnpctest_cholesky_jacobianLogDeterminant`, phi)
}

#' Get p vector, see (67) in Mittelbach et al.
#' This is unit_trace_p() in beyondWhittle(unit_trace.cpp)
#' @keywords internal
cholesky_pVec <- function(d) {
    .Call(`_vnpctest_cholesky_pVec`, d)
}

#' Get q vector, see (68) in Mittelbach et al.
#' This is unit_trace_q() in beyondWhittle(unit_trace.cpp)
#' @keywords internal
cholesky_qVec <- function(d) {
    .Call(`_vnpctest_cholesky_qVec`, d)
}

rcpp_hello_world <- function() {
    .Call(`_vnpctest_rcpp_hello_world`)
}

